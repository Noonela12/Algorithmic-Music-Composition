# -*- coding: utf-8 -*-
"""Music_Generation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1znUKj76KJrQ7EfI75aXQKybMuxiLKGiI
"""

!pip install music21

from music21 import stream, note, chord, duration


pitch_mapping = {
    0: 'C', 1: 'C#', 2: 'D', 3: 'D#', 4: 'E', 5: 'F', 6: 'F#', 7: 'G', 8: 'G#', 9: 'A', 10: 'A#', 11: 'B'
}


rhythm_mapping = {
    0: 'whole', 1: 'half', 2: 'quarter', 3: 'eighth', 4: '16th', 5: '32nd', 6: '64th', 7: '128th'
}


chord_mapping = {
    0: 'major', 1: 'minor', 2: 'diminished', 3: 'augmented', 4: '7th', 5: 'major7', 6: 'minor7', 7: 'diminished7',
    8: 'augmented7', 9: 'major6', 10: 'minor6', 11: 'suspended4', 12: 'suspended2', 13: '9th', 14: '11th', 15: '13th',
    16: 'major9', 17: 'minor9', 18: 'diminished9', 19: 'augmented9', 20: 'major11', 21: 'minor11', 22: 'diminished11',
    23: 'augmented11', 24: 'major13', 25: 'minor13', 26: 'diminished13', 27: 'augmented13', 28: 'maj7#11', 29: 'min7b5',
    30: 'maj7b5', 31: 'min7#11', 32: 'maj7#5', 33: 'dom7b5', 34: 'dom7#5', 35: 'maj7b13'
}

def pitch_to_note(pitch_index):
    return pitch_mapping.get(pitch_index, 'C')

def rhythm_to_duration(rhythm_index):
    return duration.Duration(rhythm_mapping.get(rhythm_index, 'quarter'))

def chord_to_chord(chord_index, root_pitch):
    chord_notes = [note.Note(pitch_to_note(root_pitch))]
    chord_type = chord_mapping.get(chord_index, 'major')
    if chord_type == 'major':
        chord_notes.extend([note.Note(pitch_to_note((root_pitch + i) % 12)) for i in [4, 7]])
    elif chord_type == 'minor':
        chord_notes.extend([note.Note(pitch_to_note((root_pitch + i) % 12)) for i in [3, 7]])
    return chord.Chord(chord_notes)

def sequence_to_stream(pitch_sequence, rhythm_sequence, chord_sequence):
    composition_stream = stream.Score()
    melody_part = stream.Part()
    rhythm_part = stream.Part()

    for pitch, rhythm, chord_index in zip(pitch_sequence, rhythm_sequence, chord_sequence):
        melody_note = note.Note(pitch_to_note(pitch))
        melody_note.duration = rhythm_to_duration(rhythm)
        melody_part.append(melody_note)

        chord_note = chord_to_chord(chord_index, pitch)
        chord_note.duration = rhythm_to_duration(rhythm)
        rhythm_part.append(chord_note)

    composition_stream.append(melody_part)
    composition_stream.append(rhythm_part)

    return composition_stream

import numpy as np
import random

NUM_PITCHES = 12
NUM_RHYTHMS = 8
NUM_CHORDS = 36
MOTIF_SIZE = 4
TRANSFORMATION_TYPES = ['transposition', 'inversion']


def normalize_matrix(matrix):
    row_sums = matrix.sum(axis=1)
    row_sums[row_sums == 0] = 1
    return matrix / row_sums[:, np.newaxis]

def generate_random_matrix(size):
    matrix = np.random.rand(size, size)
    return normalize_matrix(matrix)

def create_random_genome():
    pitch_matrix = generate_random_matrix(NUM_PITCHES)
    rhythm_matrix = generate_random_matrix(NUM_RHYTHMS)
    chord_matrix = generate_random_matrix(NUM_CHORDS)
    return pitch_matrix, rhythm_matrix, chord_matrix

def generate_composition(pitch_matrix, rhythm_matrix, chord_matrix, length):
    pitch_sequence = [np.random.choice(NUM_PITCHES)]
    rhythm_sequence = [np.random.choice(NUM_RHYTHMS)]
    chord_sequence = [np.random.choice(NUM_CHORDS)]

    for _ in range(length - 1):
        current_pitch = pitch_sequence[-1]
        current_rhythm = rhythm_sequence[-1]
        current_chord = chord_sequence[-1]

        next_pitch = np.random.choice(NUM_PITCHES, p=pitch_matrix[current_pitch])
        next_rhythm = np.random.choice(NUM_RHYTHMS, p=rhythm_matrix[current_rhythm])
        next_chord = np.random.choice(NUM_CHORDS, p=chord_matrix[current_chord])

        pitch_sequence.append(next_pitch)
        rhythm_sequence.append(next_rhythm)
        chord_sequence.append(next_chord)

    return pitch_sequence, rhythm_sequence, chord_sequence

def generate_motives():
    """Generate a set of primary motives."""
    motives = []
    for _ in range(5):
        motive = np.random.randint(0, NUM_PITCHES, size=MOTIF_SIZE)
        motives.append(motive)
    return motives

def apply_transformation(motive, transformation_type):
    if transformation_type == 'transposition':
        transposition = np.random.randint(NUM_PITCHES)
        return (motive + transposition) % NUM_PITCHES
    elif transformation_type == 'inversion':
        return (-motive) % NUM_PITCHES
    return motive

def create_variations(motives):
    variations = []
    for motive in motives:
        for t in TRANSFORMATION_TYPES:
            variations.append(apply_transformation(motive, t))
    return variations

class EarModule:
    def __init__(self):
        self.chromosomes = self.generate_random_chromosomes()

    def generate_random_chromosomes(self):

        chromosomes = []
        for _ in range(10):
            chromosome = np.random.randint(0, 2, size=NUM_PITCHES)
            chromosomes.append(chromosome)
        return chromosomes

    def evaluate_transition(self, transition, chromosome):
        """Check if the transition is valid according to the chromosome."""
        transition_bits = np.array([1 if i in transition else 0 for i in range(NUM_PITCHES)])
        return np.all(transition_bits & chromosome == transition_bits)

    def evaluate_composition(self, pitch_sequence, rhythm_sequence, chord_sequence, motives):
        """Evaluate a composition based on ear chromosomes and motives."""
        score = 0
        for chrom in self.chromosomes:
            for motive in motives:
                valid = True
                for i in range(len(pitch_sequence) - 1):
                    transition = (pitch_sequence[i], pitch_sequence[i+1])
                    if not self.evaluate_transition(transition, chrom):
                        valid = False
                        break
                if valid:
                    score += 1
        return score

def crossover_and_mutate(g1, g2, mutation_prob=0.1):
    pitch_matrix1, rhythm_matrix1, chord_matrix1 = g1
    pitch_matrix2, rhythm_matrix2, chord_matrix2 = g2

    new_pitch_matrix = (pitch_matrix1 + pitch_matrix2) / 2
    new_rhythm_matrix = (rhythm_matrix1 + rhythm_matrix2) / 2
    new_chord_matrix = (chord_matrix1 + chord_matrix2) / 2

    if random.random() < mutation_prob:
        mutation_matrix = generate_random_matrix(NUM_PITCHES)
        new_pitch_matrix = (new_pitch_matrix + mutation_matrix) / 2
        new_pitch_matrix = normalize_matrix(new_pitch_matrix)

    if random.random() < mutation_prob:
        mutation_matrix = generate_random_matrix(NUM_RHYTHMS)
        new_rhythm_matrix = (new_rhythm_matrix + mutation_matrix) / 2
        new_rhythm_matrix = normalize_matrix(new_rhythm_matrix)

    if random.random() < mutation_prob:
        mutation_matrix = generate_random_matrix(NUM_CHORDS)
        new_chord_matrix = (new_chord_matrix + mutation_matrix) / 2
        new_chord_matrix = normalize_matrix(new_chord_matrix)

    return new_pitch_matrix, new_rhythm_matrix, new_chord_matrix

def genetic_algorithm(population_size=10, num_generations=20, composition_length=16, score_threshold=10):
    ear_module = EarModule()
    motives = generate_motives()
    population = [create_random_genome() for _ in range(population_size)]

    generation = 0
    best_score = 0

    while generation < num_generations and best_score < score_threshold:
        compositions = [generate_composition(*genome, composition_length) for genome in population]
        scores = [ear_module.evaluate_composition(*comp, motives) for comp in compositions]

        best_score = max(scores)

        if best_score >= score_threshold:
            print("Score threshold reached. Stopping early.")
            break

        top_indices = np.argsort(scores)[-2:]
        best_genomes = [population[i] for i in top_indices]

        new_population = []
        for _ in range(population_size):
            g1, g2 = random.sample(best_genomes, 2)
            new_genome = crossover_and_mutate(g1, g2)
            new_population.append(new_genome)


        new_population.extend(best_genomes)


        population = new_population[:population_size]

        generation += 1


    final_compositions = [generate_composition(*genome, composition_length) for genome in population]
    final_scores = [ear_module.evaluate_composition(*comp, motives) for comp in final_compositions]


    sorted_indices = np.argsort(final_scores)[::-1]
    top_compositions = [final_compositions[i] for i in sorted_indices[:10]]

    return top_compositions

top_compositions = genetic_algorithm()


for i, (pitch_sequence, rhythm_sequence, chord_sequence) in enumerate(top_compositions):
    composition_stream = sequence_to_stream(pitch_sequence, rhythm_sequence, chord_sequence)


    midi_filename = f"composition_{i + 1}.midi"
    composition_stream.write('midi', fp=midi_filename)


    xml_filename = f"composition_{i + 1}.musicxml"
    composition_stream.write('musicxml', fp=xml_filename)

    print(f"Saved Composition {i + 1} to {midi_filename} and {xml_filename}")